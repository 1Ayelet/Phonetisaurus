\hypertarget{_rnn_l_m_py_8h}{}\section{src/include/\+Rnn\+L\+M\+Py.h File Reference}
\label{_rnn_l_m_py_8h}\index{src/include/\+Rnn\+L\+M\+Py.\+h@{src/include/\+Rnn\+L\+M\+Py.\+h}}
{\ttfamily \#include $<$fst/fstlib.\+h$>$}\\*
{\ttfamily \#include \char`\"{}rnnlmlib.\+h\char`\"{}}\\*
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{struct_utt_result}{Utt\+Result}
\item 
class \hyperlink{class_rnn_l_m_py}{Rnn\+L\+M\+Py}
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct \hyperlink{struct_utt_result}{Utt\+Result} \hyperlink{_rnn_l_m_py_8h_a39293dc5c67633aebf4432ad3781ac8a}{Utt\+Result}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Python bindings for Rnn\+LM. These only correspond to basic evaluation functions, not training. By default the evaluations utilizes the -\/independent convention from the original rnnlm tool. This is all we are interested in for G2P evaluations. 

\subsection{Typedef Documentation}
\index{Rnn\+L\+M\+Py.\+h@{Rnn\+L\+M\+Py.\+h}!Utt\+Result@{Utt\+Result}}
\index{Utt\+Result@{Utt\+Result}!Rnn\+L\+M\+Py.\+h@{Rnn\+L\+M\+Py.\+h}}
\subsubsection[{Utt\+Result}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf Utt\+Result}  {\bf Utt\+Result}}\hypertarget{_rnn_l_m_py_8h_a39293dc5c67633aebf4432ad3781ac8a}{}\label{_rnn_l_m_py_8h_a39293dc5c67633aebf4432ad3781ac8a}
